#!/bin/bash

сравнение целых чисел:

[[ -eq ]] [[ = ]]  (( = ))	равно  
[[ -ne ]] [[ != ]] (( != ))	не равно
[[ -gt ]] [[ > ]]  (( > ))	больше
[[ -ge ]] [[ >= ]] (( >= ))	больше или равно
[[ -lt ]] [[ < ]]  (( < ))	меньше
[[ -le ]] [[ <= ]] (( <= ))	меньше или равно

если использовать не числовые значения со скобками то будет сравниваться значение asci символов

[[ -z ]] - строка/аргумент пустая
[[ -n ]] - строка/аргумент не пустая


[[ command -a command ]] - то же что и && 
[[ command -o command ]] - то же что и ||


[[ -e file ]]	существует 
[[ -f file ]]	существует и является обычным файлом
[[ -d file ]]	существует и является каталогом
[[ -r file ]]	существует с разрешениями на чтение
[[ -w file ]]	существует с разрешениями на запись
[[ -x file ]]	существует с разрешениями на выполнение
[[ -s file ]]	существует и размер файла больше нуля
[[ -O file ]]	существует, и владельцем является действующий идентификатор пользователя
[[ -G file ]]	существует, и владельцем является действующий идентификатор группы
[[ -h file ]]	существует и является символической ссылкой
[[ -L file ]]	существует и является символической ссылкой
[[ -b file ]]	существует и является блочным устройством
[[ -c file ]]	существует и является character-special файлом
[[ -S file ]]	существует и является socket-файлом
[[ -N file ]]	существует и был изменен с момента последнего чтения
[[ file1 -ef file2 ]]	пренадлежат одному и тому же файлу/инoду
[[ file1 -nt file2 ]]	file1 новее file2
[[ file1 -ot file2 ]]	file1 старше file2


id++ id--	переменный постинкремент и постдекремент
++id --id	переменный преинкремент и предекремент
- +		унарный минус и плюс
! ~		логическое и побитовое отрицание
**		возведение в степень
* / %		умножение, деление, остаток
+ -		сложение, вычитание
<< >>		побитовые сдвиги влево и вправо
== !=		равенство и неравенство 
& 		побитовое И
^ 		побитовое исключающее ИЛИ
| 		побитовое ИЛИ
&& 		логическое И
|| 		логическое ИЛИ
expr ? expr : expr				условный оператор
= *= /= %= += -= <<= >>= &= ^= |=		назначение
expr1 , expr2					запятая
<<< 						оператор перенаправления, позволяющий использовать строку в качестве стандартного ввода для команды

$0 - возвращает путь до исполняемого скрипта 
$# - возвращает число входных параметров
$@ - возвращает массив всех входных параметров c с разделителем ($1 $2 $3 ...)
$$ - возвращает PID текущего процесса
$! - возвращает PID предыдущего процесса
$? - возвращает статус выхода последней команды
$* - возвращает все входнфе параметры без разделителя ($1$2...)
$- - возвращает возвращает стандрартные для оболочки аргументы





VIM
/nohl выключить подцветку vim 
Command	Information
:e myfile	Открывает «myfile» для редактирования
:w		Сохраните файл
:sav myfile.txt	Сохраняет файл как myfile.txt
:q!		Выйти без сохранения изменений
:q		Выйти 
/xyz		Искать xyz сверху вниз
?xyz		Искать xyz снизу вверх
*		Поиск текста под курсором
/\ctext		Поиск текста (без учета регистра)
/ra[av]i	Поиск raai или ravi
/abc\|xyz	Поиск abc или xyz
/\<\d\d\d\d\>	поиск числа с 4 цифрами
/^\n\{3}	поиск 3 пустых строк всподряд
:bufdo /searchstr/	поиск во всех открытых файлах глобально
bufdo %s/findme/replaceme/g	поиск findme во всех открытых буферах и замена его на replaceme
:%s/x/y/g	замена всех вхождений  x на y в файле
:%s/qwerty/ytrewq/gi	замена qwerty на ytrewq без учета регистр
:%s/x/y/gc	замена всех вхождений после подтверждения
:%s/^/Begin/g	вставка в начало каждой строки Begin
:%s/$/End/g	вставка в конец каждой строки End
:%s/x/y/gi	
:%s/ *$//g	удаление всех пробелов
:g/myname/d	удаление всех строк содержащих myname
:v/myname/d	удаление всех строк НЕ содержащих myname
:s/John/Doe/	заменить первое вхождение John на Doe в текущей строке
:s/John/Doe/g	Заменить John на Doe в текущей строке
:%s/John/Doe/g	Заменить John на Doe во всех файлах
:%s/^M//g	Поиск и удаление возврата каретки DOS (^M)
:%s/\r/\r/g	аменить возврат каретки DOS обычным ключом возврата (\r)
:%s#<[^>]\+>##g 	поиск и удаление тегов html
:%s/^\(.*\)\n\1$/\1/	gоиск и удаление повторяющихся строк
Ctrl+a	увеличивает число под курсором
Ctrl+x	уменьшает число под курсором

Vim Commands for Cut, Copy and Paste
y	копировать выбранный текст
p	вставить выбранный текст
dd	вырезать выбранную строку
yy	вставить выбранную строку
y$	
D	


Vim Commands to Change Case

Vu	сменить все буквы на строчные в строке
VU	сменить все буквы на Заглавные в строке
g~~	инвертировать регистр
vEU	перевести выбранное слово в верхний регистр
vE~	инвертировать регистр выбранного слова
ggguG	установить весь текст в нижнем регистре
gggUG	установить весь текст в верхнем регистре
:set ignorecase		игнорировать регистр при поиске текста
:set smartcase		игнорировать регистр при поиске, но не в том случае, если используется заглавная буква
:%s/\<./\u&/g		устанавливает первую букву каждого слова в верхний регистр
:%s/\<./\l&/g		устанавливает первую букву каждого слова в нижний регистр
:%s/.*/\u&		устанавливает первую букву каждой строки в верхний регистр
:%s/.*/\l&		устанавливает первую букву каждой строки в нижний регистр

Navigation within the File

k или стрелка вверх	переместить позицию курсора вверх на одну строку
j или стрелка вниз	переместить позицию курсора вниз на одну строку
e	переместить курсор в конец слова
b	переместить курсор в начало слова
O	Переместить курсор в начало строки
G	Переместить курсор в EOF
gg	переместить курсор в начало файла
L	переместить курсор в нижнюю часть экрана
:80	переместить курсор на строку номер 80
%	переместить курсор к соответствующей скобке
[[	переместить курсор к запуску функции
[{	переместить курсор в начало блока

File R/W and File Explorer

:1,10 w myfile		сохранить строки с 1 по 10 в myfile
:1,10 w >> myfile	добавить строки с 1 по 10 в myfile
:r myfile		вставить содержимое myfile в текущий файл
:23r myfile		вставить содержимое myfile в строку 23
:e .			открыть проводник
:Sex			разделить окно и открыть проводник
:Sex!			То же, что и :Sex , но разделяет окно по вертикали
:browse e		графический файловый менеджер
:ls			список буферов
:cd ..			Перейти в родительский или корневой каталог
:args			список файлов
:args *.php		Список открытых файлов с расширением .php
:grep something *.php	Возвращает список файлов .php, содержащих что-либо
gf			открыть  имя файла под курсором

Interface-Related Vim Commands (Tabs and Windows)

:tabnew		открыть новую вкладку
gt		перейти к следующей вкладке
:tabfirst	перейти к первой вкладке
:tablast	перейти к последней вкладке
:tabm n(position)	переупорядочить открытые вкладки
:tabdo %s/foo/bar/g	выполнить одну и ту же команду на всех вкладках
:tab ball		помещает все открытые файлы в разные вкладки
:new myfile.txt		открыть myfile.txt в новом окне
:e filename		изменить имя файла в текущем окне
:split myfile		разделить окно и откройте myfile
ctrl-w + стрелка вверх	поместить курсор в верхнее окно
ctrl-w ctrl-w (дважды)	поместить курсор в следующее окно
ctrl-w_			развернуть текущее окно по вертикали
ctrl-w|			развернуть текущее окно по горизонтали
ctrl-w=			сделать все окна одинакового размера
100 ctrl-w+		добавить 100 строк в файл в текущем окне
:vsplit file		разделить окна по вертикали
:sview file		Разделить окна по вертикали (только для чтения)
:hide			закрыть текущее окно
:­nly			 закрыть все окна, кроме текущего
:b 4 			открыть вкладку №4 в текущем окне

Text Alignment and Indentation

:set autoindent		включить автоматический отступ
:%!fmt			выровнять все строки
!}fmt			выровнять все строки в текущей позиции
2!!fmt			выровнять следующие две строки
:set smartindent	включите интеллектуальный автоматический отступ
:set shiftwidth=8	определяет 8 пробелов в качестве размера отступа
ctrl-t, ctrl-d		отступ и снятие отступа в режиме вставки
>>			отступ текущей строки
<<			убрать отступ текущей строки
=%			отступ кода между скобками
1GVG=			отступ для всего файла

Autocomplete Vim Commands

Ctrl+n Ctrl+p	завершить предложенное слово (режим вставки)
Ctrl+x Ctrl+l	завершить предложенную строку
:set dictionary=en	выбрать EN в качестве активного словаря
Ctrl+x Ctrl+k		завершить с помощью активоного словаря

UNIX-Only Vim Commands
:!get	выполнить команду get, затем вернуться в Vim.
!!get	выполнить команду get, затем вставить вывод в текущий файл
:sh	перейти в оболочку unix
$exit	выйти из оболочки Unix и вернуться в Vim

Miscellaneous Vim Commands

m {q-p}	установить метку на выбранной позиции {q-p}
‘ {q-p}	перейти к ранее помеченной позиции {q-p}
“	перейти к предыдущей метке
:ab mail hi@designbombs.com	задать почте адрес hi@designbombs.com




ebegin
Как и einfo, мы выводим полезное сообщение, а затем намекаем, что выполнение следующей операции может занять некоторое время. Как только задача будет завершена, вам нужно вызвать end.

eend
Дополните сообщение ebegin соответствующим «ОК» или «!!». (для ошибок) маркер. Если статус не равен нулю, отображается дополнительное сообщение об ошибке.

einfo
То же, что и elog, но его следует использовать, когда сообщение не важно для пользователя (например, сообщения о ходе выполнения или статусе в процессе сборки).

elog
Если вам нужно отобразить сообщение, которое вы хотите, чтобы пользователь прочитал и принял к сведению, используйте elog. Он работает точно так же, как echo(1), но немного добавляет к выводу, чтобы привлечь внимание пользователя. Сообщение также будет зарегистрировано Portage для последующего просмотра.

eqawarn
То же, что и einfo, но его следует использовать при отображении предупреждения QA пользователю.

ewarn
То же, что и einfo, но следует использовать при отображении предупреждения пользователю.

Чтобы загрузить исходные коды с помощью ebuild, запустите:
ebuild путь/к/файлу-ebuild fetch

создать digest и manifest
ebuild путь/к/файлу-ebuild digest

распаковка исходных кодов в /var/tmp/portage (или любой другой каталог, указанный в /etc/make.conf):
ebuild путь/к/файлу-ebuild unpack

Компиляция исходных кодов ( выполняется функция src_compile() вашего сборочного файла):
ebuild путь/к/файлу-ebuild compile

если создать пустой .compiled в рабочий каталог то Portage поверит, что программа ebuild уже завершила компиляцию.

 установка всех необходимых файлов во временный каталог. В него помещаются все файлы, подлежащие включению в рабочую файловую систему. Вы можете выполнить этот этап, запустив функцию установки программы ebuild, которая исполняет функцию src_install() сборочного файла:
 ebuild путь/к/файлу-ebuild install

 Последний этап — перенос всех файлов в рабочую файловую систему и их регистрация в системе Portage. В ebuild этот этап называется "qmerge", и включает следующие действия:
-- выполняется функция pkg_preinst(), если она определена
-- все файлы копируются в рабочую файловую систему
-- файлы регистрируются в системе Portage
-- выполняется функция pkg_postinst(), если она определена
чтобы выполнить этот этап:
ebuild путь/к/файлу-ebuild qmerge

чистка tmp
ebuild путь/к/файлу-ebuild clean

Запуск всех команд установки разом:
ebuild путь/к/файлу-ebuild merge


Выполнение действий по настройке:
ebuild путь/к/файлу-ebuild config

создание пакета RPM
ebuild путь/к/файлу-ebuild rpm

узнать список зависимостей покета
emerge -p

узнать список флагов 
emerge -vp 

удалить пакет но не конфигурационные файлы
emerge -C

доудалить ненужные пакеты
emerge -c

обновление явно установленных пакетов
emerge -ua world

обновление явно установленных пакетов + их зависимостей
emerge -uDa world

Если вы меняли какие-либо из USE-флагов то Portage проверит, требует ли изменение установки новых пакетов или перекомпиляции существующих:
emerge -uDNa world

Возможны два вида зависимости:
DEPEND - зависимость сборки
RDEPEND - зависимость выполнения

Глобальное определение переменных: /etc/env.d
Локальное определение переменных: ~/.bashrc или ~/.bash_profile
Сеансовые переменные: export PATH="${PATH}:/home/my_user/tmp/usr/bin"

Потоки 

stdin - по умолчанию номер потока ВВОДА 0
stdout - по умолчанию номер потока ВЫВОДА 1
stderr - по умолчанию номер потока ОШИБОК 2


'>', '>|', '<>', '>&', '&>', '>>' - операторы перенаправления

По умолчанию оператор > всегда перенаправляет поток stdout, который имеет номер 1. Чтобы направить другой поток, надо перед оператором > поставить его номер.

command 2>file - перенаправит поток ошибок в file
command >file 2>&1 - направили поток stdout в file, а затем направит stderr туда же, куда направлен stdout с помощью оператора & перед номером потока.
find . | grep -e '/.svn$' | xargs rm -Rf -  отдаем нужные файлы команде xargs, которая вызывает rm -Rf и в качестве параметров использует свой stdin построчно

 2>&1 - Сообщения об ошибках передаются туда же, куда и стандартный вывод.
 a>&b - Вывод в файл с дескриптором a передается в файл с дескриптором b.
 >&b - Cтандартный вывод передаются в файл с дескриптором b
 0< или < - ввод из файла (прмер: grep search-word <filename)
 [j]<>filename - произвольный доступ к файлу на чтение и запись + связывается с дескриптором b
 a<&- - Закрыть дескриптор входного файла a
 0<&-, <&- - Закрыть поток ввода.
 a>&- Закрыть дескриптор выходного файла a.
 1>&-, >&- - Закрыть вывода
 
перенаправлять потоки можно утилитой exec

При использрвании дескриптора с номером 5 могут возникать проблемы. Когда Bash порождает дочерний процесс, например командой exec, то дочерний процесс наследует дескриптор 5 как "открытый". Поэтому, лучше не использовать этот дескриптор
	

name="John"
echo "${name}"
echo "${name/J/j}"    #=> "john" (substitution)
echo "${name:0:2}"    #=> "Jo" (slicing)
echo "${name::2}"     #=> "Jo" (slicing)
echo "${name::-1}"    #=> "Joh" (slicing)
echo "${name:(-1)}"   #=> "n" (slicing from right)
echo "${name:(-2):1}" #=> "h" (slicing from right)
echo "${food:-Cake}"  #=> $food or "Cake"

length=2
echo "${name:0:length}"  #=> "Jo"

str="/path/to/foo.cpp"
echo "${str%.cpp}"    # /path/to/foo
echo "${str%.cpp}.o"  # /path/to/foo.o
echo "${str%/*}"      # /path/to
echo "${str##*.}"     # cpp (extension)
echo "${str##*/}"     # foo.cpp (basepath)
echo "${str#*/}"      # path/to/foo.cpp
echo "${str##*/}"     # foo.cpp
echo "${str/foo/bar}" # /path/to/bar.cpp

str="Hello world"
echo "${str:6:5}"   # "world"
echo "${str: -5:5}"  # "world"
src="/path/to/foo.cpp"
base=${src##*/}   #=> "foo.cpp" (basepath)
dir=${src%$base}  #=> "/path/to/" (dirpath)

str="HELLO WORLD!"
echo "${str,}"   #=> "hELLO WORLD!" (lowercase 1st letter)
echo "${str,,}"  #=> "hello world!" (all lowercase)

str="hello world!"
echo "${str^}"   #=> "Hello world!" (uppercase 1st letter)
echo "${str^^}"  #=> "HELLO WORLD!" (all uppercase
